from random import *
import time
import matplotlib.pyplot as plt 
from NoeudUCT import *

# Fonction Globale

# Retourne la liste des quadruplets gagnants du plateau nb_ligne*nb_colonne
def quadrupletsGagnants(nb_ligne,nb_colonne):
	res = list()
	dir = [(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)] #Dans l'ordre : Bas ,Bas-Droite, Droite, Haut-Droite, Haut, Haut-Gauche, Gauche, Bas-Gauche


	for x in range(0,nb_ligne):
		for y in range(0,nb_colonne):
			for direction in dir:

				nombreCase = 0
				currentX = x
				currentY = y
				currentQuadruplet = {(x,y)}
				(deplacementX,deplacementY) = direction

				while  nombreCase < 3:
					if (currentX + deplacementX < nb_ligne and currentX + deplacementX >= 0) and (currentY + deplacementY < nb_colonne and currentY + deplacementY >= 0):
						currentX += deplacementX
						currentY += deplacementY
						currentQuadruplet.add((currentX,currentY))
						nombreCase += 1
					else:
						break

				if nombreCase == 3:
					if currentQuadruplet not in res:
						res.append(currentQuadruplet)

	return res

# Retourne une copie du plateau passé en paramètre
def copiePlateau(plateau):

    nouveauPlateau = Plateau(nb_ligne,nb_colonne)
    for x in range(0,nb_ligne):
        for y in range(0,nb_colonne):
            nouveauPlateau.plateau[x][y] = plateau.plateau[x][y]


    return nouveauPlateau

# Retourne le nombre de parties différentes possibles
def calculNbPartiesDifferentes(jeu,cpt):


    compteurPartie = 0
    if(jeu.isFinished()):
        return 1

    elif(cpt % 2 == 0):
        listeCoupsPossibles = jeu.plateau.coupsPossibles()

        for coup in listeCoupsPossibles:
            nouveauJeu = Jeu(jeu.plateau,jeu.joueur1,jeu.joueur2)
            nouveauJeu.plateau = copiePlateau(jeu.plateau)
            nouveauJeu.plateau.ajouterPion(coup,jeu.joueur1)
            compteurPartie = compteurPartie + calculNbPartiesDifferentes(nouveauJeu,cpt + 1)

    else:

        listeCoupsPossibles = jeu.plateau.coupsPossibles()

        for coup in listeCoupsPossibles:
            nouveauJeu = Jeu(jeu.plateau,jeu.joueur1,jeu.joueur2)
            nouveauJeu.plateau = copiePlateau(jeu.plateau)
            nouveauJeu.plateau.ajouterPion(coup,jeu.joueur2)
            compteurPartie = compteurPartie + calculNbPartiesDifferentes(nouveauJeu,cpt + 1)

    return compteurPartie

# Q.5 : Exécute 10*100000 parties et pour chacune, écris la probabilité : nbNulle/nbTotal dans un fichier
def writeProbaNulle(jeu):
	repetition = 0
	while repetition < 10:
		nbNulle = 0
		i = 0
		while i < 100000 :
			result = jeu.run(False)
			if not result :
				nbNulle += 1
			i += 1

		file = open('ProbaPartieNulle','a')
		file.write(str(nbNulle)+"/"+str(i)+"\n")

		repetition += 1

# Variables globales
nb_ligne = 6
nb_colonne = 7
NmonteCarlo = 1000
listeQuadrupletsGagnants = quadrupletsGagnants(nb_ligne,nb_colonne)


# Classes

# Classe représentant le plateau de jeu
class Plateau:

	def __init__(self,nb_ligne,nb_colonne):
		self.nb_ligne = nb_ligne
		self.nb_colonne = nb_colonne
		self.quadrupletsGagnants = listeQuadrupletsGagnants
		self.plateau = []
		self.initPlateau()

	# Initialise le plateau à un plateau 2D de nb_ligne*nb_colonne rempli de 0
	def initPlateau(self):
		tab = []
		for _ in range(0,self.nb_ligne):
			for _ in range(0,self.nb_colonne):
				tab.append(0)

			self.plateau.append(tab)
			tab = []

	# Rempli le plateau de 0
	def reset(self):
		for i in range(0,len(self.plateau)):
			for j in range(0,len(self.plateau[i])):
				self.plateau[i][j] = 0

	# Retourne True si le plateau est rempli (i.e toutes les cases != 0), False sinon
	def estRempli(self):
		for i in range(0,len(self.plateau)):
			for j in range(0,len(self.plateau[i])):
				if self.plateau[i][j] == 0:
					return False
		return True

	# Ajoute un pion dans le plateau dans la colonne passée en paramètre
	def ajouterPion(self,colonne,joueur):
		for ligne in range(0,self.nb_ligne):
			if self.plateau[ligne][colonne] != 0:
				self.plateau[ligne - 1][colonne] = joueur.couleur
				break
			elif ligne == self.nb_ligne - 1:
				self.plateau[ligne][colonne] = joueur.couleur
				break

	# Retourne la liste des coups possibles, un coup est considérée possible quand il y a au moins une case vide dans la colonne 
	def coupsPossibles(self):
		res = []
		derniereLigne = self.plateau[0]
		for j in range(0,len(derniereLigne)):
			if derniereLigne[j] == 0:
				res.append(j)
		return res

	# Affiche le plateau
	def show(self):
		print()
		for ligne in self.plateau:
			print(ligne)
		print()

# Classe représentant un joueur réel
class JoueurReel:

	def __init__(self,couleur):
		self.couleur = couleur

	# Calcul un coup aléatoirement et place le pion dans le plateau
	def play(self,plateau):
		choixJoueur = input("Colonne à jouer (entre 1 et 7) : ")
		colonneJouee = int(choixJoueur) - 1
		plateau.ajouterPion(colonneJouee,self)

	# Retourne True si le joueur a réalisé un quadruplet gagnant, False sinon
	def hasWon(self,plateau):
		for quadruplets in plateau.quadrupletsGagnants:

			nombreCase = 0
			for elem in quadruplets:

				(ligne,colonne) = elem
				couleur = plateau.plateau[ligne][colonne]

				if couleur == 0 or couleur != self.couleur:
					break
				elif nombreCase > 0 and couleur != couleurPrec:
					break

				nombreCase += 1
				couleurPrec = couleur

			if nombreCase == 4:
				return True

		return False


# Classe représentant un joueur aléatoire
class JoueurAlea:

	def __init__(self,couleur):
		self.couleur = couleur

	# Calcul un coup aléatoirement et place le pion dans le plateau
	def play(self,plateau):
		coupsPossibles = plateau.coupsPossibles()
		colonneJouee = coupsPossibles[randint(0,len(coupsPossibles)-1)]
		plateau.ajouterPion(colonneJouee,self)

	# Retourne True si le joueur a réalisé un quadruplet gagnant, False sinon
	def hasWon(self,plateau):
		for quadruplets in plateau.quadrupletsGagnants:

			nombreCase = 0
			for elem in quadruplets:

				(ligne,colonne) = elem
				couleur = plateau.plateau[ligne][colonne]

				if couleur == 0 or couleur != self.couleur:
					break
				elif nombreCase > 0 and couleur != couleurPrec:
					break

				nombreCase += 1
				couleurPrec = couleur

			if nombreCase == 4:
				return True

		return False

class JoueurMonteCarlo:

	def __init__(self,couleur):
		self.couleur = couleur

	# Calcul un coup en suivant l'algorithme de Monte Carlo et place le pion dans le plateau
	def play(self,plateau):
		# Initialiser les récompenses des actions à 0
		tabResAction = []
		for _ in range(0,nb_colonne):
			# On enregistre à la case i, la liste des résultats des parties de l'action i (colonne i)
			tabResAction.append([])

		if self.couleur == 1:
			couleurAdversaire = -1
		else:
			couleurAdversaire = 1

		# Pour i de 0 à N-1
		for i in range(0,NmonteCarlo):
			# Choisir une action au hasard
			actionsPossibles = plateau.coupsPossibles()
			actionAlea = actionsPossibles[randint(0,len(actionsPossibles) - 1)]

			# Jouer les deux joueurs au hasard + Mettre à jour la récompense de l'action en fonction du résultat
			newPlateau = copiePlateau(plateau)
			newPlateau.ajouterPion(actionAlea,self)

			if Jeu(newPlateau,JoueurAlea(self.couleur),JoueurAlea(couleurAdversaire)).run(False) == self.couleur:
				tabResAction[actionAlea].append(1)
			else:
				tabResAction[actionAlea].append(0)

		# Retourner l'action avec la meilleure probabilité de victoire
		meilleureAction = -1
		moyenneMax = -1.0
		currentAction = 0

		for listeRes in tabResAction:
			nbTotal = 0
			nbWin = 0

			for res in listeRes:
				nbWin += res
				nbTotal += 1

			if nbTotal:
				moyenne = (nbWin*1.0/nbTotal)

				if moyenneMax < moyenne:
					moyenneMax = moyenne
					meilleureAction = currentAction

			currentAction += 1

		# On joue la meilleure action
		plateau.ajouterPion(meilleureAction,self)

	# Retourne True si le joueur a réalisé un quadruplet gagnant, False sinon
	def hasWon(self,plateau):
		for quadruplets in plateau.quadrupletsGagnants:

			nombreCase = 0
			for elem in quadruplets:

				(ligne,colonne) = elem
				couleur = plateau.plateau[ligne][colonne]

				if couleur == 0 or couleur != self.couleur:
					break
				elif nombreCase > 0 and couleur != couleurPrec:
					break

				nombreCase += 1
				couleurPrec = couleur

			if nombreCase == 4:
				return True

		return False

class JoueurUCT:

	def __init__(self,couleur):
		self.couleur = couleur

	# Calcul un coup en suivant l'algorithme de Monte Carlo et place le pion dans le plateau
	def play(self,plateau):
		# On initialise le joueur adverse
		if self.couleur == 1:
			joueurAdv = JoueurAlea(-1)
		else:
			joueurAdv = JoueurAlea(1)

		# On initialise la racine et ses enfants
		racine = NoeudUCT(-1,None,copiePlateau(plateau),None)

		for _ in range(0,racine.nbCoupsPossibles):
			colonne = racine.coupsPossibles[0]
			newPlateau = copiePlateau(plateau)
			newPlateau.ajouterPion(colonne,self)

			# Si l'enfant est une feuille
			if newPlateau.estRempli() or self.hasWon(newPlateau):
				plateau.ajouterPion(colonne,self)
				return

			# Sinon on simule la partie
			recompense = 0
			if Jeu(copiePlateau(newPlateau),JoueurAlea(self.couleur),JoueurAlea(joueurAdv.couleur)).run(False) == self.couleur:
				recompense = 1

			# On ajoute le noeud enfant à la racine
			racine.ajouterEnfant(NoeudUCT(colonne,(recompense,1),copiePlateau(newPlateau),racine))

		for i in range(0,NmonteCarlo):
			# Selection
			noeudChoisi = racine.dfsUCB()

			# Expansion / Simulation
			if noeudChoisi.isLeaf:
				(nbWin,nbTotal) = noeudChoisi.valeur
				# La recompense pour une feuille ne peut être que 1 ou 0
				recompense = nbWin/nbTotal
				noeudChoisi.retroPropag(int(recompense))
				continue
			# Si ce n'est pas une feuille, on choisit une action aléatoire et on la simule
			actionAlea = noeudChoisi.coupsPossibles[randint(0,len(noeudChoisi.coupsPossibles) - 1)]
			newPlateau = copiePlateau(noeudChoisi.plateau)

			if noeudChoisi.couleur == 1:
				newPlateau.ajouterPion(actionAlea,joueurAdv)
			else:
				newPlateau.ajouterPion(actionAlea,self)

			# On crée le nouveau noeud associé à cet état de la partie
			nouveauNoeud = NoeudUCT(actionAlea,(0,0),copiePlateau(newPlateau),noeudChoisi)
			noeudChoisi.ajouterEnfant(nouveauNoeud)

			# Si ce noeud est une feuille, il faut le noter
			if newPlateau.estRempli() or self.hasWon(newPlateau) or joueurAdv.hasWon(newPlateau):
				nouveauNoeud.isLeaf = True

			# On simule la partie à partir de cette action
			if nouveauNoeud.couleur == 1:
				# C'est l'adversaire qui joue
				resultat = Jeu(newPlateau,JoueurAlea(joueurAdv.couleur),JoueurAlea(self.couleur)).run(False)
			else:
				resultat = Jeu(newPlateau,JoueurAlea(self.couleur),JoueurAlea(joueurAdv.couleur)).run(False)

			recompense = 0
			if resultat == self.couleur:
				recompense = 1

			# Retro-propagation
			nouveauNoeud.retroPropag(recompense)

		# On détermine la meilleure action parmi les enfants de la racine
		rendementMax = -0xFFFFFFFF
		meilleureAction = -1
		for enfant in racine.enfants:

			(nbWin,nbTotal) = enfant.valeur
			rendement = nbWin/nbTotal
			if rendement > rendementMax:
				rendementMax = rendement
				meilleureAction = enfant.id

		# On joue la meilleure action
		plateau.ajouterPion(meilleureAction,self)

	# Retourne True si le joueur a réalisé un quadruplet gagnant, False sinon
	def hasWon(self,plateau):
		for quadruplets in plateau.quadrupletsGagnants:

			nombreCase = 0
			for elem in quadruplets:

				(ligne,colonne) = elem
				couleur = plateau.plateau[ligne][colonne]

				if couleur == 0 or couleur != self.couleur:
					break
				elif nombreCase > 0 and couleur != couleurPrec:
					break

				nombreCase += 1
				couleurPrec = couleur

			if nombreCase == 4:
				return True

		return False

# Classe représentant une partie de jeu
class Jeu:

	def __init__(self,plateau,joueur1,joueur2):
		self.plateau = plateau
		self.joueur1 = joueur1
		self.joueur2 = joueur2

	# Lance une partie de jeu 
	def run(self,show):

		i = 0
		while not self.isFinished():
			# Pour modifier le comportement d'un joueur, mettre la fonction play() correspondante
			if i%2 == 0:
				self.joueur1.play(self.plateau)
			else:
				self.joueur2.play(self.plateau)
			i += 1

			if show:
				time.sleep(1)
				self.plateau.show()

		if self.joueur1.hasWon(self.plateau):
			if self.plateau == plateauDeBase:
				file = open('NbCoupsJoueur1UCT300ItérationsVSMonteCarlo','a')
				file.write(str(i) + '\n')

			return self.joueur1.couleur
		elif self.joueur2.hasWon(self.plateau):
			if self.plateau == plateauDeBase:
				file = open('NbCoupsJoueur2MonteCarlo300ItérationsVSUCT','a')
				file.write(str(i) + '\n')

			return self.joueur2.couleur
		else:
			return 0

	# Retourne True si un des deux joueurs a gagné ou si le plateau est rempli, on pourrait optimiser le temps de calcul en passant en paramètre le joueur qui vient de jouer
	def isFinished(self):
		return self.joueur1.hasWon(self.plateau) or self.joueur2.hasWon(self.plateau) or self.plateau.estRempli()

plateauDeBase = Plateau(nb_ligne,nb_colonne)

# Point d'entrée
def main():
	Jeu(plateauDeBase,JoueurUCT(1),JoueurReel(-1)).run(True)

main()