import math

class NoeudUCT:
	def __init__(self,id,valeur,plateau,pere):
		self.id = id
		self.valeur = valeur
		self.plateau = plateau
		self.coupsPossibles = plateau.coupsPossibles()
		self.nbCoupsPossibles = len(self.coupsPossibles)
		self.pere = pere
		self.isLeaf = False
		self.enfants = []
		if self.pere and self.pere.couleur == -1:
			self.couleur = 1
		else:
			self.couleur = -1
		

	def ajouterEnfant(self,noeud):
		self.coupsPossibles.remove(noeud.id)
		self.enfants.append(noeud)


	def dfsUCB(self):

		if len(self.enfants) != self.nbCoupsPossibles:
			return self

		# On ex√©cute UCB
		t = 0
		for enfant in self.enfants:
			(nbWin,nbTotal) = enfant.valeur
			t += nbTotal

		argMax = -0xFFFFFFFF
		noeudChoisi = None
		for enfant in self.enfants:
			if enfant.isLeaf:
				return enfant

			(nbWin,nbTotal) = enfant.valeur
			arg = ((nbWin * 1.0)/nbTotal) + math.sqrt((2* math.log(t))/nbTotal) 

			if argMax < arg:
				argMax = arg
				noeudChoisi = enfant

		return noeudChoisi.dfsUCB()


	def retroPropag(self,recompense):
		if not self.valeur:
			return

		(nbWin,nbTotal) = self.valeur
		if self.couleur == 1:	
			self.valeur = (nbWin + recompense, nbTotal + 1)
		elif recompense == 0:
			self.valeur = (nbWin + 1, nbTotal + 1)
		else:
			self.valeur = (nbWin, nbTotal + 1)
		self.pere.retroPropag(recompense)